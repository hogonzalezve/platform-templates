# platform-templates/templates/microservice-with-rds.yaml
apiVersion: scaffolder.backstage.io/v1beta3
kind: Template
metadata:
  name: microservice-with-rds-v2
  title: Microservice + AWS RDS (Fixed)
  description: Crea o reutiliza un micro con DB en AWS (Crossplane), K8s manifests y CI.
spec:
  owner: group:platform-team
  type: service
  parameters:
    - title: Datos del servicio
      required: [serviceName, namespace, domain, org]
      properties:
        serviceName: { type: string, pattern: "^[a-z0-9-]+$", description: "nombre corto: p.ej. orders" }
        namespace:   { type: string, pattern: "^[a-z0-9-]+$", description: "namespace K8s: p.ej. team-a" }
        domain:      { type: string, description: "FQDN: p.ej. orders.nttdataco.com" }
        org:         { type: string, description: "Organización o usuario GitHub (ej: mi-org)" }
        team:        { type: string, description: "Nombre del equipo o squad (ej: team-a)" }
        useExistingRepos: { type: boolean, default: true, description: "Si ya creaste repos a mano, marca true" }
    - title: Repositorios
      properties:
        appRepoUrl:     { type: string, description: "github.com?owner=ORG&repo=ms-<svc>-app" }
        k8sRepoUrl:     { type: string, description: "github.com?owner=ORG&repo=ms-<svc>-k8s" }
        claimsRepoUrl:  { type: string, description: "github.com?owner=ORG&repo=tenant-<team>-claims" }
    - title: Parámetros de DB
      properties:
        dbEngine:    { type: string, enum: [postgres, mysql], default: postgres }
        dbVersion:   { type: string, default: "15" }
        dbStorageGi: { type: integer, default: 20 }
        dbInstance:  { type: string, default: "db.t4g.micro" }
    - title: Almacenamiento App
      properties:
        pvcSizeGi:   { type: integer, default: 5 }

  steps:
    # A) Crear repos SOLO si no existen
    - id: create-app
      name: Crear repo de app
      if: ${{ parameters.useExistingRepos == false }}
      action: github:repo:create
      input:
        repoUrl: github.com?owner=${{ parameters.org }}&repo=ms-${{ parameters.serviceName }}-app
        repoVisibility: private
        description: "Microservice application generated by Backstage"

    - id: create-k8s
      name: Crear repo de k8s
      if: ${{ parameters.useExistingRepos == false }}
      action: github:repo:create
      input:
        repoUrl: github.com?owner=${{ parameters.org }}&repo=ms-${{ parameters.serviceName }}-k8s
        repoVisibility: private
        description: "Kubernetes manifests for ${{ parameters.serviceName }} microservice"

    - id: create-claims
      name: Crear repo de claims
      if: ${{ parameters.useExistingRepos == false }}
      action: github:repo:create
      input:
        repoUrl: github.com?owner=${{ parameters.org }}&repo=tenant-${{ parameters.namespace }}-claims
        repoVisibility: private
        description: "Database claims for ${{ parameters.namespace }} team"

    # B) Generar APP (copia el skeleton app-node a un directorio temporal)
    - id: seed-app
      name: Crear app (Dockerfile + CI)
      action: fetch:template
      input:
        url: ../skeletons/app-node
        targetPath: ./work/app
        values:
          serviceName: ${{ parameters.serviceName }}

    # C) Publicar APP en el repo (existente o recién creado)
    - id: publish-app
      name: Publicar APP en repo
      action: github:repo:push
      input:
        repoUrl: github.com?owner=${{ parameters.org }}&repo=ms-${{ parameters.serviceName }}-app
        defaultBranch: main
        sourcePath: ./work/app
        gitCommitMessage: "Scaffolded application - ${{ '' | now }}"
        gitAuthorName: "Backstage Scaffolder"
        gitAuthorEmail: "scaffolder@backstage.io"

    # D) Generar K8s (ns, pvc, deployment, service, ingress)
    - id: seed-k8s
      name: Crear k8s
      action: fetch:template
      input:
        url: ../skeletons/k8s
        targetPath: ./work/k8s
        values:
          serviceName: ${{ parameters.serviceName }}
          namespace:   ${{ parameters.namespace }}
          domain:      ${{ parameters.domain }}
          pvcSizeGi:   ${{ parameters.pvcSizeGi }}

    # E) Publicar K8s en su repo
    - id: publish-k8s
      name: Publicar k8s en repo
      action: github:repo:push
      input:
        repoUrl: github.com?owner=${{ parameters.org }}&repo=ms-${{ parameters.serviceName }}-k8s
        defaultBranch: main
        sourcePath: ./work/k8s
        gitCommitMessage: "Kubernetes manifests - ${{ '' | now }}"
        gitAuthorName: "Backstage Scaffolder"
        gitAuthorEmail: "scaffolder@backstage.io"

    # F) Generar Claim de DB (Crossplane)
    - id: seed-claim
      name: Generar claim DB (Crossplane)
      action: fetch:template
      input:
        url: ../skeletons/claim-db
        targetPath: ./work/claim
        values:
          serviceName: ${{ parameters.serviceName }}
          namespace:   ${{ parameters.namespace }}
          dbEngine:    ${{ parameters.dbEngine }}
          dbVersion:   ${{ parameters.dbVersion }}
          dbStorageGi: ${{ parameters.dbStorageGi }}
          dbInstance:  ${{ parameters.dbInstance }}

    # G) Publicar Claim en el repo de claims (equipo)
    - id: publish-claim
      name: Publicar claim en repo de equipo
      action: github:repo:push
      input:
        repoUrl: github.com?owner=${{ parameters.org }}&repo=tenant-${{ parameters.namespace }}-claims
        defaultBranch: main
        sourcePath: ./work/claim
        # targetPath: databases/${{ parameters.serviceName }}
        gitCommitMessage: "Database claim for ${{ parameters.serviceName }} - ${{ '' | now }}"
        gitAuthorName: "Backstage Scaffolder"
        gitAuthorEmail: "scaffolder@backstage.io"

  output:
    links:
      - title: Repo app
        url: ${{ steps.publish-app.output.remoteUrl }}
      - title: Repo k8s
        url: ${{ steps.publish-k8s.output.remoteUrl }}
      - title: Repo claims
        url: ${{ steps.publish-claim.output.remoteUrl }}
